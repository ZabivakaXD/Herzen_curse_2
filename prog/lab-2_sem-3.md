# Лабораторная работа №2

## Задание 1.1

Создайте простое замыкание (closure) в виде внутренней (вложенной)
функции внутри обычной функции. Внутренняя функция (замыкание, closure) должна использовать переменные и аргументы обычной
функции, в которую она вложена. Внутри внутренней функции (closure)
распечатайте переданные аргументы в терминале. Верните вложенную функцию из обычной функции с помощью выражения return.
```
def foo(author, x):
    """Пример замыкания
    """

    author = 'Zhukov'  # enclosing, внешняя,
    x = 400

    # объемлющая
    def inner_boo(author, x) -> dict:
        print(author, x + 1)
        return {'author': author, 'year': x + 1}

    return inner_boo

f = foo("Bolotov", 2024)
f_s = f("Kostya", 19)

f_s
```
[ссылка на файл](https://github.com/ZabivakaXD/Herzen_curse_2/blob/main/prog/clouser.py)

## Задание 1.2

Изучите на примерах в интернете, что такое closure и и как их применять для создания простого декоратора (decorator) с @-синтаксисом
в Python. Модернизируйте калькулятор из задачи 3.1 лабораторной
работы №1. Декорируйте вашу функцию calculate. В соответствующем декорирующем замыкании, в сlosure, то есть во внутренней
функции используйте простое логирование (стандартный модуль Python
logging). Сделайте логирование внутри замыкания до вызова вашей
функции
calculate(operand1, operand2, action), в котором логируется информация о том какие операнды и какая арифметическая операция
собираются поступить на вход функции
calculate(operand1, operand2, action). Затем внутри того же closure
следует сам вызов функции calculate(...). А затем, после этого вызова должно быть снова логирование, но уже с результатом выполнения вычисления, проделанного в этой функции.

```
def log_decorator(func):
    """Decorate
    """
    def wrapper(numbers, operand, tolerance):
        """Closure

        Логируется информация о том какие операнды и какая арифметическая операция собираются поступить на вход функции.
        Затем внутри того же closure следует сам вызов функции calculate(...).
        А затем, после этого снова логирование, но уже с результатом выполнения вычисления, проделанного в этой функции.

        Возвращает результат выражения
        """
        logging.info(f'Вызов функции {func.__name__} с параметрами: numbers={numbers}, operand="{operand}", tolerance={tolerance}')
        result = func(numbers, operand, tolerance)
        logging.info(f'Результат выполнения функции {func.__name__}: {result}')
        return result
    return wrapper
```
[ссылка на файл](https://github.com/ZabivakaXD/Herzen_curse_2/blob/main/prog/Calculate.py)
[ссылка на логи](https://github.com/ZabivakaXD/Herzen_curse_2/blob/main/prog/Calculate.log)

## Задание 1.3

Изучите основы каррирования. Каррирование в самом простом варианте - это создание специализированной функции на основе более общей функции с предустановленными параметрами для этой более
общей функции. Реализуйте каррирование на примере вычисления количества радиоактивного вещества N, оставшегося в некоторый момент времени t от радокактивного вещества с периодом полураспада t1/2, если изначально это количество было равно N0. Закон распада
задан формулой:

[img-1](https://github.com/ZabivakaXD/Herzen_curse_2/blob/main/prog/img/lab-2_sem-3.png)

В качестве проставленного заранее параметра в данном примере должно быть значение периода полураспада t1/2, которое постоянно для
каждого типа радиоактивного материала (радиоактивного изотопа химического элемента). Сделайте словарь, где в качестве колючей используются строки с символами радиоактивных изотопов, а в качестве значений им сопоставлены каррированные с характерными периодами полураспада. В основном коде вашей программы организуйте цикл по этому словарю и продемонстрируйте в нём вызовы каррированных функций с распечаткой на экране сколько вещества осталось от одного и того же N0 в некоторый момент времени t в зависимости от типа изотопа.

```
def decay(N0, t, t_half):
    """
    Вычисляет количество радиоактивного вещества N, оставшегося через время t.
    
    :param N0: Начальное количество вещества
    :param t: Прошедшее время
    :param t_half: Период полураспада
    :return: Оставшееся количество вещества
    """
    return N0 * (1 / 2) ** (t / t_half)

def curry_t_half(t_half):
    """
    Каррированная функция для фиксированного периода полураспада.
    
    :param t_half: Период полураспада
    :return: Функция, принимающая N0 и t
    """
    return lambda N0, t: decay(N0, t, t_half)

# Словарь с радиоактивными изотопами и их периодами полураспада
isotopes = {
    "C-14": 5730,  # Период полураспада в годах
    "U-238": 4500000000,  # Период полураспада в годах
    "Ra-226": 1600,  # Период полураспада в годах
}

# Начальное количество вещества и время
N0 = 1000  # Начальное количество вещества
t = 1000  # Прошедшее время в годах

# Цикл по словарю и вызов каррированных функций
for isotope, t_half in isotopes.items():
    decay_function = curry_t_half(t_half)
    remaining_amount = decay_function(N0, t)
    print(f"Для изотопа {isotope} осталось {remaining_amount:.2f} единиц вещества через {t} лет.")
```
[ссылка на файл](https://github.com/ZabivakaXD/Herzen_curse_2/blob/main/prog/Calculate.py)